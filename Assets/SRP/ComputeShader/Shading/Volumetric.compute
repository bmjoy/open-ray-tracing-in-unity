#ifndef Volumetric_COMPUTE
#define Volumetric_COMPUTE

// [shader(Volumetric)]
void Volumetric_SecRays(
    inout Ray ray,
    RayHit hit,
    inout SecRaysAtHit secRaysAtHit
) 
{
    if (ray.gen <= 1) {
        return;
    }

    // Reflective
    secRaysAtHit.srays[0].origin = hit.position;
    secRaysAtHit.srays[0].direction = normalize(reflect(ray.direction, hit.normal));
    secRaysAtHit.srays[0].color = float3(0, 0, 0);
    secRaysAtHit.srays[0].gen = ray.gen - 1;
    secRaysAtHit.srays[0].inside = 0;   // Reflective ray is outside of the object
    secRaysAtHit.srays[0].medium = 0;   // Reflective ray did not enter the object, medium is air
    secRaysAtHit.srays[0].tmin = 0.01f;
    secRaysAtHit.srays[0].weight = 0;

    // Translucent
    secRaysAtHit.srays[1].origin = hit.position;
    secRaysAtHit.srays[1].direction = ray.direction;
    secRaysAtHit.srays[1].color = float3(0, 0, 0);
    secRaysAtHit.srays[1].gen = ray.gen - 1;
    secRaysAtHit.srays[1].inside = 1;   // Reflective ray is inside of the object
    secRaysAtHit.srays[1].medium = hit.mediumToEnter;   // Translucent ray enter the object
    secRaysAtHit.srays[1].tmin = 0.01f;
    secRaysAtHit.srays[1].weight = 1;
}

float3 Volumetric(
   inout Ray ray,
   RayHit hit,
   float3 ambientLightUpper,
   float3 secondaryRayColor
)
{
    if (ray.inside == 1)
    {
        float3 color = float3(1, 1, 1);

        float travel = hit.distance;

        while (travel > 0)
        {
            travel -= 0.2f;

            float3 lightAmt = float3(0, 0, 0);

            for(int l = 0; l < _NumOfLights; l++)
            {
                LightHit light0 = GetIlluminate(hit.position + -1 * ray.direction * travel, hit.primitiveId, l);

                lightAmt += light0.color;
            }

            lightAmt = clamp(lightAmt, float3(0, 0, 0), float3(1, 1, 1));
            
            color = min(color, lightAmt);
        }

        return color * secondaryRayColor;
    }
    return secondaryRayColor;
}

#endif // Volumetric_COMPUTE 