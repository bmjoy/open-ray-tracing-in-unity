#ifndef RTSphere_Intersect_Compute
#define RTSphere_Intersect_Compute

// [intersect(RTSphere)]

struct RTSphere
{
    float3 center;
    float radius;
};

StructuredBuffer<RTSphere> _RTSpheres;

void RTSphereIntersect(Ray ray, inout RayHit bestHit, Primitive primitive, int primitiveId)
{
    // For every sphere in the primitive, we do:

    // Step 1: Define

    // From origin to center
    // float3 oriToCtr = sphere.xyz - ray.origin;
    // float e = distance(oriToCtr);
    
    // Vector projection to get the distance the ray will travel in the direction until to the point that is perpendicular to the sphere center
    // float a = dot(ray.direction, oriToCtr);

    // Distance from center to the perpendicular point.
    // float b^2 = e^2 - a^2

    // Step 2: Distinguish between point inside or outside the sphere

    // If the sphere is outside: e > r
    // Do Step 3a. Otherwise, do step 3b.

    // Step 3a: Discriminant

    // dat = r^2 - b^2
    // If dat > 0, there are a hit
    // If dat < 0, there is no hit, continue to next sphere

    // Distance from hit point to the perpendicular point.
    // float f^2 = r^2 - b^2 = dat
    // f = sqrt(dat)

    // Step 4a: Calculate t

    // Distance from origin to hit point (our target)
    // origin ---t--> hit point ---f--> perpendicular point
    // float t = a - f
    // t = a - f

    // Step 3b:


    // Step 5: Check if t is valid and best hit


    [fastopt] for(int s = 0; s < primitive.geometryInstanceCount; s++)
    {
        RTSphere sphere = _RTSpheres[primitive.geometryInstanceBegin + s];
        float t = -1;

        // Step 1: Define

        float3 oriToCtr = sphere.center - ray.origin;

        float e = length(oriToCtr);

        float a = dot(ray.direction, oriToCtr);

        float b2 = e * e - a * a;

        float3 hp = float3(0, 0, 0);
        float3 n = float3(0, 0, 0);
        int mediumToEnter = 0;

        float dat = sphere.radius * sphere.radius - b2;

        // Step 2: Determine if the origin is outside the sphere
        // Check the truth table for the selection of inside vs outside algorithm
        // Currently, the prototype use a separated field "ray.inside" to replace the truth table
        if (ray.inside == 0 || (ray.inside == -1 && e > sphere.radius))
        {
            // Outside, do step 3a:
            if (dat < 0)
            {
                continue; // No intersection, bypass
            }

            // Step 4a:
            float f = sqrt(dat);

            t = abs(a - f);
            hp = ray.origin + t * ray.direction;

            n = normalize(hp - sphere.center);

            if (dot(ray.direction, n) >= 0)
            {
                // The hit normal is not "intercepting" the ray direction, we may intersecting behind the sphere surface due to origin placing just behind the surface due to floating point error
                continue;
            }

            mediumToEnter = primitiveId;
            
        }
        else
        {
            // On or inside, do step 3b
            float f = sqrt(dat);

            t = a + f;
            hp = ray.origin + t * ray.direction;

            mediumToEnter = 0;
            n = normalize(sphere.center - hp);
        }

        // Step 4: Update best hit distance
        if (ray.tmin < t && t < ray.tmax && t < bestHit.distance)
        {
            bestHit.distance = t;
            bestHit.primitiveId = primitiveId;
            bestHit.position = hp;
            bestHit.mediumToEnter = mediumToEnter;
            bestHit.normal = n;
            // bestHit.matIndex = sphere.matIndex;
        }
    }
}

#endif