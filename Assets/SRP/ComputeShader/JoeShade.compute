#include "Ray.compute"
#include "RayHit.compute"
#include "DataStructure/LightInfo.compute"
#include "DataStructure/LightHit.compute"
#include "Primitive/Primitive.compute"
#include "BVH/RTBoundingBox.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Camera
float4 _CameraForward;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

// Ray Generation
int _RayGenID;

//Skybox
Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

// Primitive
int _NumOfPrimitive;
StructuredBuffer<Primitive> _Primitives;

// BVH
StructuredBuffer<RTBoundingBox> _BVHTree;

// Light
int _NumOfLights;
StructuredBuffer<LightInfo> _Lights;

// Ambient
float3 _AmbientLightUpper;

// Placeholder
float3 missShader(float3 direction) {
    // Sample the skybox and write it
    float theta = acos(direction.y) / -3.14159265359f;
    float phi = atan2(direction.x, -direction.z) / -3.14159265359f * 0.5f;
    return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
}

#include "RayCasting/Trace.compute"

#include "Custom/RayGeneration/CustomRayGeneration.compute"

#include "Custom/Geometry/CustomGeometry.compute"

#include "Custom/Lights/CustomLights.compute"

#include "Shading/CustomShaderCollection.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// MAX_RAY_GENERATION = 8;
// MAX_SECONDARY_RAYS_PER_GENERATION = 8;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);

    uint numberOfRay = NumberOfRay(width, height, id, _RayGenID);

    float4 finalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

    for (uint i = 0; i < numberOfRay; i++) {
        Ray ray = RayGeneration(width, height, id, _RayGenID, i);

        // Trace
        RayHit hit = Trace(ray, _NumOfPrimitive);    // Exclude nothing

        float3 result;
        if (hit.primitiveId == -1) {
            // Miss Shader
            result = float3(0, 0, 0);
        } else {
            
            Ray secondaryRays[32];
            int secondaryRaysJump[64];  //[even]: start; [old]: count
            int initialEntry[2];    //[0]:start; [1]:count
            initialEntry[0] = 0;
            initialEntry[1] = 0;
            
            Ray secRays[4];
            SecRays(ray, hit, secRays);
            for (int i = 0; i < 4; i++) {
                
            }

            // Closet Hit Shader
            result = ClosestHit(
                ray,
                hit,
                _AmbientLightUpper
            );
        }
            
        finalColor += float4(result, 1) / numberOfRay;
    }
    
    Result[id.xy] = finalColor;


}
