#include "Ray.compute"
#include "RayHit.compute"
#include "DataStructure/LightInfo.compute"
#include "DataStructure/LightHit.compute"
#include "Primitive/Primitive.compute"
#include "BVH/RTBoundingBox.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Camera
float4 _CameraForward;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

// Ray Generation
int _RayGenID;

// Primitive
int _NumOfPrimitive;
StructuredBuffer<Primitive> _Primitives;

// BVH
StructuredBuffer<RTBoundingBox> _BVHTree;

// Light
int _NumOfLights;
StructuredBuffer<LightInfo> _Lights;

// Ambient
float3 _AmbientLightUpper;

#include "RayCasting/Trace.compute"

#include "Custom/RayGeneration/CustomRayGeneration.compute"

#include "Custom/Geometry/CustomGeometry.compute"

#include "Custom/Lights/CustomLights.compute"

#include "Shading/CustomShaderCollection.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);

    uint numberOfRay = NumberOfRay(width, height, id, _RayGenID);

    float4 finalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

    for (uint i = 0; i < numberOfRay; i++) {
        Ray ray = RayGeneration(width, height, id, _RayGenID, i);

        // Trace
        RayHit hit = Trace(ray,
                        _NumOfPrimitive);    // Exclude nothing

            float3 result;
            if (hit.primitiveId == -1) {
                // Miss Shader
                result = float3(0, 0, 0);
            } else {
                // Closet Hit Shader
                result = Shade(
                    ray,
                    hit,
                    _AmbientLightUpper
                );
            }
            
        finalColor += float4(result, 1) / numberOfRay;
    }
    
    Result[id.xy] = finalColor;


}
